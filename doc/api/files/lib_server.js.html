<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib\server.js - EeeZorBot API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="EeeZorBot API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/api.html">api</a></li>
            
                <li><a href="../classes/Channel.html">Channel</a></li>
            
                <li><a href="../classes/debug.html">debug</a></li>
            
                <li><a href="../classes/Listdb.html">Listdb</a></li>
            
                <li><a href="../classes/log.html">log</a></li>
            
                <li><a href="../classes/owners.html">owners</a></li>
            
                <li><a href="../classes/Script.html">Script</a></li>
            
                <li><a href="../classes/server.html">server</a></li>
            
                <li><a href="../classes/stdin.html">stdin</a></li>
            
                <li><a href="../classes/tools.html">tools</a></li>
            
                <li><a href="../classes/User.html">User</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/api.html">api</a></li>
            
                <li><a href="../modules/channel.html">channel</a></li>
            
                <li><a href="../modules/debug.html">debug</a></li>
            
                <li><a href="../modules/listdb.html">listdb</a></li>
            
                <li><a href="../modules/log.html">log</a></li>
            
                <li><a href="../modules/owners.html">owners</a></li>
            
                <li><a href="../modules/script.html">script</a></li>
            
                <li><a href="../modules/server.html">server</a></li>
            
                <li><a href="../modules/stdin.html">stdin</a></li>
            
                <li><a href="../modules/tools.html">tools</a></li>
            
                <li><a href="../modules/user.html">user</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: lib\server.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var Channel = require(&#x27;./channel.js&#x27;),
	User = require(&#x27;./user.js&#x27;),
	owners = require(&#x27;./owners.js&#x27;),
	Script = require(&#x27;./script.js&#x27;),
	net = require(&#x27;net&#x27;),
	tools = require(&#x27;./tools.js&#x27;),
	log = require(&#x27;./log.js&#x27;),
	stdin = require(&#x27;./stdin.js&#x27;),
	debug = require(&#x27;./debug.js&#x27;);
process.on(&#x27;SIGINT&#x27;,function(){
	stdin.stop();
	process.exit();
});
/**
 * IRC Server object
 * @module server
 * @class server
 * @constructor
 * @param {object} config
 */
module.exports = function(config){
	var self = this,
		defaults = {
			host: &#x27;&#x27;,
			port: 6667,
			nick: &#x27;&#x27;,
			username: &#x27;&#x27;,
			name: &#x27;&#x27;,
			nickserv: undefined,
			channels: [],
			scripts: [],
			showping: false
		},
		sid = 0,
		i,
		ii;
	for(i in defaults){
		if(config[i] === undefined){
			config[i] = defaults[i];
		}
	}
	/**
	 * Array of channels on the server
	 * @property channels
	 * @type {Array}
	 */
	self.channels = [];
	/**
	 * Array of users on the server that are known
	 * @property users
	 * @type {Array}
	 */
	self.users = [];
	/**
	 * Array of all hooks installed on the server
	 * @property hooks
	 * @type {Array}
	 */
	self.hooks = [];
	/**
	 * Array of all the scripts installed on the server
	 * @property scripts
	 * @type {Array}
	 */
	self.scripts  = [];
	/**
	 * Array of all the commands on the server
	 * @property commands
	 * @type {Object}
	 */
	self.commands = {};
	/**
	 * Server config
	 * @property config
	 * @type {Object}
	 */
	self.config = {};
	/**
	 * Run function in the context of a specific script
	 * @method run
	 * @param {number} id Script ID to run under (0 == run as server)
	 * @param {function} fn function to run
	 * @chainable
	 */
	self.run = function(id,fn){
		var osid = sid;
		sid = id;
		fn.call(self,sid);
		sid = osid;
		return self;
	};
	for(i in config){
		switch(i){
			case &#x27;channels&#x27;:break;
			case &#x27;scripts&#x27;:break;
			default:
				self.config[i] = config[i];
		}
	}
	/**
	 * Log something in the context of the server
	 * @method log
	 * @param {mixed} msg Message to log
	 * @chainable
	 */
	self.log = function(msg){
		log.alert(&#x27;[&#x27;+self.config.host+&#x27;:&#x27;+self.config.port+&#x27;] &#x27;+msg);
		return self;
	};
	/**
	 * Log something in the context of the server
	 * @method info
	 * @param {mixed} msg Message to log
	 * @chainable
	 */
	self.info = function(msg){
		log.info(&#x27;[&#x27;+self.config.host+&#x27;:&#x27;+self.config.port+&#x27;] &#x27;+msg);
		return self;
	};
	/**
	 * Log something in the context of the server
	 * @method debug
	 * @param {mixed} msg Message to log
	 * @chainable
	 */
	self.debug = function(msg){
		debug.log(&#x27;[&#x27;+self.config.host+&#x27;:&#x27;+self.config.port+&#x27;] &#x27;+msg);
		return self;
	};
	/**
	 * Log something in the context of the server
	 * @method error
	 * @param {mixed} msg Message to log
	 * @chainable
	 */
	self.error = function(msg){
		log.error(&#x27;[&#x27;+self.config.host+&#x27;:&#x27;+self.config.port+&#x27;] &#x27;+msg);
		return self;
	};
	/**
	 * log.in something in the context of the server
	 * @method logIn
	 * @param {mixed} msg Message to log
	 * @chainable
	 */
	self.logIn = function(msg){
		log.in(&#x27;[&#x27;+self.config.host+&#x27;:&#x27;+self.config.port+&#x27;] &#x27;+msg);
		return self;
	};
	/**
	 * log.out something in the context of the server
	 * @method logOut
	 * @param {mixed} msg Message to log
	 * @chainable
	 */
	self.logOut = function(msg){
		log.out(&#x27;[&#x27;+self.config.host+&#x27;:&#x27;+self.config.port+&#x27;] &#x27;+msg);
		return self;
	};
	/**
	 * log.error something in the context of the server
	 * @method logError
	 * @param {mixed} msg Message to log
	 * @chainable
	 */
	self.logError = function(msg){
		log.error(&#x27;[&#x27;+self.config.host+&#x27;:&#x27;+self.config.port+&#x27;] &#x27;+msg);
		return self;
	};
	/**
	 * Connect to the IRC server
	 * @method connect
	 * @chainable
	 */
	self.connect = function(){
		if(self.socket === undefined){
			log.log(&#x27;Connecting to &#x27;+self.config.host+&#x27;:&#x27;+self.config.port);
			self.socket = new net.Socket();
			self.socket.setNoDelay(true);
			self.socket.setEncoding(&#x27;ascii&#x27;);
			self.socket.on(&#x27;connect&#x27;,function(){
				self.info(&#x27;Connection established (evt)&#x27;);
				self.fire(&#x27;connect&#x27;,arguments,self);
			});
			self.socket.on(&#x27;data&#x27;,function(d){
				self.fire(&#x27;data&#x27;,arguments,self);
				var s = d.split(&quot;\r\n&quot;),
					i,
					ii,
					match,
					hook,
					m,
					o;
				for(ii=0;ii&lt;s.length;ii++){
					if(s[ii] !== &#x27;&#x27;){
						m = /^PING :(.+)/i.exec(s[ii]);
						if(m){
							if(self.config.showping){
								self.logIn(s[ii]);
							}else{
								o = log.config.levels.out;
								log.config.levels.out = false;
							}
							self.send(&#x27;PONG :&#x27;+m[1]);
							if(!self.config.showping){
								log.config.levels.out = o;
							}
							self.fire(&#x27;ping&#x27;,arguments,self);
						}else{
							self.logIn(s[ii]);
						}
						for(i=0;i&lt;self.hooks.length;i++){
							hook = self.hooks[i];
							if(hook.type == &#x27;regex&#x27;){
								match = hook.regex.exec(s[ii]);
								if(match){
									hook.fn.call(self,match,s[ii]);
									if(hook.once){
										self.hooks.splice(i,1);
									}
								}
							}
						}
					}
				}
				// TODO - incoming data
			});
			self.socket.on(&#x27;drain&#x27;,function(){
				self.debug(&#x27;Drain event&#x27;);
				self.fire(&#x27;drain&#x27;,arguments,self);
				// TODO - No more outgoing data
			});
			self.socket.on(&#x27;error&#x27;,function(e){
				self.info(&#x27;Connection errored&#x27;);
				self.fire(&#x27;error&#x27;,arguments,self);
				self.error(e);
			});
			self.socket.on(&#x27;timeout&#x27;,function(){
				self.info(&#x27;Connection timed out&#x27;);
				self.fire(&#x27;timeout&#x27;,arguments,self);
				self.reconnect();
			});
			self.socket.on(&#x27;end&#x27;,function(){
				self.info(&#x27;Connection ended&#x27;);
				self.fire(&#x27;end&#x27;,arguments,self);
				// TODO - server closed connection
			});
			self.socket.on(&#x27;close&#x27;,function(e){
				self.fire(&#x27;close&#x27;,arguments,self);
				if(e){
					self.info(&#x27;Connection closed due to an error&#x27;);
					// TODO - socket was closed due to error
				}else{
					self.info(&#x27;Connection closed&#x27;);
					// TODO - socket closure was intended
				}
			});
			self.socket.connect(self.config.port,self.config.host,function(){
				self.info(&#x27;Connection established&#x27;);
				self.send(&#x27;NICK &#x27;+self.config.nick);
				self.send(&#x27;USER &#x27;+self.config.name+&#x27; localhost * &#x27;+self.config.name);
			});
		}
		return self;
	};
	/**
	 * Send a message to the IRC server
	 * @method send
	 * @param {string} d Message to send
	 * @chainable
	 */
	self.send = function(d){
		if(d.length &gt; 510){
			self.fire(&#x27;error&#x27;,[new Error(&#x27;Send String too long&#x27;)],self);
			return self;
		}
		try{
			if(self.socket){
				self.socket.write(d+&#x27;\r\n&#x27;,&#x27;ascii&#x27;,function(){
					self.logOut(d);
					self.fire(&#x27;send&#x27;,[d],self);
				});
			}
		}catch(e){
			self.error(e);
			self.fire(&#x27;error&#x27;,[e],self);
		}
		return self;
	};
	/**
	 * Install a hook on the server.
	 * @method on
	 * @param {string|RegExp} hook Hook to install (can be named or RegExp)
	 * @param {function} callback Callback to run when the hook fires
	 * @param {boolean} [once=false] Should this hook uninstall itself when it is run?
	 * @chainable
	 */
	self.on = function(hook,callback,once){
		self.debug(&#x27; |  |- Hook &#x27;+hook);
		once = once===undefined?false:once;
		if(hook instanceof RegExp){
			self.hooks.push({
				type: &#x27;regex&#x27;,
				regex: hook,
				fn: callback,
				once: once,
				sid: sid
			});
		}else{
			self.hooks.push({
				type: &#x27;event&#x27;,
				name: hook,
				fn: callback,
				once: once,
				sid: sid
			});
		}
		return self;
	};
	/**
	 * Uninstall a hook from the server
	 * @method off
	 * @param {string|RegExp} hook Hook to remove
	 * @param {function} [callback] callback used in the hook you want to remove
	 * @chainable
	 */
	self.off = function(hook,callback){
		var i,
			h,
			t;
		for(i=0;i&lt;self.hooks.length;i++){
			h = self.hooks[i];
			t = arguments.length === 0;
			if(sid === h.sid){
				if(!t){
					if(hook instanceof RegExp &amp;&amp; h.type == &#x27;regex&#x27; &amp;&amp; h.regex === hook){
						t = true;
					}else if(h.type == &#x27;event&#x27; &amp;&amp; h.name === hook){
						t = true;
					}else if(hook === undefined){
						t = true;
					}
					t = t &amp;&amp; (callback === undefined || h.fn === callback);
				}
				if(t){
					self.hooks.splice(i,1);
				}
			}
		}
		return self;
	};
	/**
	 * Add a command to the server
	 * @method add
	 * @param {string} command Command name (used to invoke command)
	 * @param {function} callback Callback to run when command invoked
	 * @param {string} help Help line for the command
	 * @chainable
	 */
	self.add = function(command,callback,help){
		if(self.commands[command] === undefined){
			self.debug(&#x27; |  |- Command &#x27;+command);
			self.commands[command] = {
				fn: callback,
				sid: sid,
				help: help
			};
		}
		return self;
	};
	/**
	 * Remove a command listener from the server
	 * @method remove
	 * @param {string} command Command you want to remove
	 * @chainable
	 */
	self.remove = function(command){
		var i,
			n = {};
		if(command === undefined){
			for(i in self.commands){
				if(self.commands[i].sid !== sid){
					n[i] = self.commands[i];
				}
			}
			self.commands = n;
		}else{
			for(i in self.commands){
				if(i !== command){
					n[i] = self.commands[i];
				}
			}
			self.commands = n;
		}
		return self;
	};
	/**
	 * Fire an event on the IRC server
	 * @method fire
	 * @param {string} name Name of the event to trigger
	 * @param {array} args Arguments to provide the event callbacks
	 * @param {mixed} scope What the event callbacks should use for the &#x27;this&#x27; keyword
	 * @chainable
	 */
	self.fire = function(name,args,scope){
		var i,
			hook;
		scope = scope===undefined?self:scope;
		args = args===undefined?[]:args;
		for(i=0;i&lt;self.hooks.length;i++){
			hook = self.hooks[i];
			if(hook.type == &#x27;event&#x27; &amp;&amp; hook.name == name){
				try{
					hook.fn.apply(scope,args);
				}catch(e){
					self.error(e);
				}
			}
		}
		return self;
	};
	/**
	 * Join a channel
	 * @method join
	 * @param {string} name Channel name
	 * @chainable
	 */
	self.join = function(name){
		// TODO - handle adding to channel array if it doesn&#x27;t already exist
		var channel = self.channel(name);
		if(!channel){
			channel = new Channel(self,name);
			self.channels.push(channel);
		}
		channel.join();
		self.fire(&#x27;join&#x27;,[name,self.config.nick],self);
		return self;
	};
	/**
	 * Leave a channel
	 * @method part
	 * @param {string} name Name of the channel
	 * @chainable
	 */
	self.part = function(name){
		var c = self.channel(name);
		if(c){
			c.part();
		}
		return self;
	};
	/**
	 * Check if in a channel
	 * @method in
	 * @param {string} name Name of the channel
	 * @return {boolean} status of server in channel
	 */
	self.in = function(name){
		// TODO - detect if actually joined to channel and not just created for shits/giggles... I mean for record keeping
		for(var i=0;i&lt;self.channels.length;i++){
			if(self.channels[i].name == name){
				return true;
			}
		}
		return false;
	};
	/**
	 * Get a channel based on it&#x27;s name
	 * @method channel
	 * @param {string} name Name of the channel
	 * @return {Channel|boolean} Returns false if channel doesn&#x27;t exist. Returns the channel otherwise
	 */
	self.channel = function(name){
		for(var i=0;i&lt;self.channels.length;i++){
			if(self.channels[i].name == name){
				return self.channels[i];
			}
		}
		return false;
	};
	/**
	 * Gets the user or syncs a user on the server
	 * @method user
	 * @param {string|User} user User object to sync or nick you want the user object for
	 * @return {User} The user object
	 */
	self.user = function(user){
		var i,
			old;
		if(user instanceof User){
			for(i=0;i&lt;self.users.length;i++){
				if(self.users[i].nick === user.nick){
					old = self.users[i];
				}
			}
			if(old !== undefined){
				for(i in user){
					old[i] = user[i];
				}
			}else{
				old = user;
				self.users.push(user);
			}
		}else{
			for(i=0;i&lt;self.users.length;i++){
				if(self.users[i].nick === user){
					old = self.users[i];
				}
			}
			old = old===undefined?false:old;
		}
		return old;
	};
	/**
	 * Gets a script based on the sid
	 * @method script
	 * @param {number} sid
	 * @return {boolean|Script} Returns false if script is not found, otherwise returns the script.
	 */
	self.script = function(sid){
		s = self.scripts[sid-1];
		return s===undefined||s===null?false:s;
	};
	/**
	 * Reconnects to the IRC server
	 * @method reconnect
	 * @chainable
	 */
	self.reconnect = function(){
		self.info(&#x27;Reconnecting&#x27;);
		self.quit();
		self.connect();
		self.fire(&#x27;reconnect&#x27;,arguments,self);
		return self;
	};
	/**
	 * Quits from the IRC server
	 * @method quit
	 * @param {string} [msg=string] Quit message. defaults to &quot;Bot shutting down&quot;.
	 * @chainable
	 */
	self.quit = function(msg){
		self.fire(&#x27;quit&#x27;,arguments,self);
		msg = msg === undefined?&#x27;Bot shutting down&#x27;:msg;
		try{
			self.send(&#x27;QUIT :&#x27;+msg);
		}catch(e){}
		try{
			self.socket.end();
		}catch(e){}
		try{
			self.socket.destroy();
		}catch(e){}
		delete self.socket;
		return self;
	};
	process.on(&#x27;exit&#x27;,function(){
		self.quit();
	});
	self.debug(&#x27;Loading server scripts&#x27;);
	self.debug(&#x27; |- lib/server.js&#x27;);
	self.on(&#x27;error&#x27;,function(e){
			self.error(e);
		})
		// RPL_WELCOME
		.on(/:.+ 001 .+ :.+/i,function(){
			var i;
			for(i=0;i&lt;config.channels.length;i++){
				self.join(config.channels[i]);
			}
			if(self.config.nickserv !== undefined){
				self.send(&#x27;PRIVMSG NickServ :identify &#x27;+self.config.nickserv.nick+&#x27; &#x27;+self.config.nickserv.password);
			}
		})
		// PRIVMSG
		.on(new RegExp(&quot;^:(\\w+)!(.+)@(.+)\\sPRIVMSG\\s(\\#?\\w+)\\s:?&quot;+tools.regexString(self.config.prefix)+&quot;(\\S+)\\s?(.+)?$&quot;,&#x27;i&#x27;),function(m){
			// 1 - nick
			// 2 - username
			// 3 - host
			// 4 - channel
			// 5 - command
			// 6 - arguments
			var c = self.commands[m[5]],
				i,
				a = m[6],
				u = self.user(m[1]),
				ch = self.channel(m[4]);
			a = a===undefined?[]:a.split(&#x27; &#x27;);
			if(ch === false){
				ch = new Channel(self,m[4]);
			}
			if(u === false){
				u = new User(m[1],m[2],m[3],&#x27;&#x27;,self);
				u.channels.push(ch);
				self.users.push(u);
			}
			if(c !== undefined){
				c.fn.apply({
					server: self,
					argv: a,
					channel: ch,
					user: u
				},a);
			}
		})
		// RPL_ENDOFWHO
		.on(new RegExp(&#x27;:.+ 315 .+ (\\S+) :End of \/WHO list.&#x27;,&#x27;i&#x27;),function(m){
			// 1 - channel
			var c = self.channel(m[1]);
			if(!c){
				c = new Channel(self,m[1]);
				self.channels.push(c);
			}
			self.fire(&#x27;who&#x27;,[c],self);
		})
		// RPL_WHOREPLY
		.on(new RegExp(&#x27;:.+ 352 .+ (.+) (.+) (.+) (.+) (.+) .+ :(\\d+) (.+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - channel
			// 2 - username
			// 3 - host
			// 4 - 
			// 5 - nick
			// 6 - 
			// 7 - realname
			var user = self.user(m[5]),
				channel = self.channel(m[1]);
			if(!channel){
				channel = new Channel(self,m[1]);
				self.channels.push(channel);
			}
			if(user){
				if(user.channels.indexOf(channel)){
					user.channels.push(channel);
				}
			}else{
				user = new User(m[5],m[2],m[3],m[7],self);
				user.channels.push(channel);
				self.user(user);
			}
			user.whois();
		})
		// RPL_WHOISUSER
		.on(new RegExp(&#x27;:.+ 311 \\S+ (\\S+) (\\S+) (\\S+) * :(.+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - nick
			// 2 - username
			// 3 - host
			// 4 - realname
			var user = self.user(m[1]),
				owner,
				i;
			if(!user){
				user = new User(m[1],m[2],m[3],m[4],self);
				self.users.push(user);
			}else{
				user.username = m[2];
				user.host = m[3];
				user.realname = m[4];
			}
			owner = owners.match(user.hostmask);
			console.log(owner);
			if(owner !== undefined){
				console.log(&#x27;Checking owner flags&#x27;);
				if(owner.flags.indexOf(&#x27;v&#x27;) != -1){
					for(i=0;i&lt;user.channels.length;i++){
						user.channels[i].mode(&#x27;+v&#x27;,user.nick);
					}
				}
			}
		})
		// RPL_WHOISCHANNELS
		.on(new RegExp(&#x27;:.+ 319 .+ (\\S+) :(.+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - Nick
			// 2 - channels
			var user = (function(nick){
					var u = self.user(nick);
					if(!u){
						u = new User(nick,&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,self);
					}
					return u;
				})(m[1]),
				channels = m[2].split(&#x27; &#x27;),
				i,
				ii,
				channel,
				modes,
				mode;
			user.modes = {};
			for(i=0;i &lt; channels.length;i++){
				channel = channels[i];
				modes = channel.substr(0,channel.indexOf(&#x27;#&#x27;));
				channel = channel.substr(channel.indexOf(&#x27;#&#x27;));
				channel = self.channel(channel);
				if(!channel){
					channel = new Channel(self,channels[i]);
					self.channels.push(channel);
				}
				if(user.channels.indexOf(channel) == -1){
					user.channels.push(channel);
				}
				user.modes[channel.name] = [];
				for(ii=0;ii &lt; modes.length;ii++){
					mode = modes[i];
					switch(mode){
						case &#x27;+&#x27;:
							mode=&#x27;v&#x27;;
						break;
						case &#x27;%&#x27;:
							mode=&#x27;h&#x27;;
						break;
						case &#x27;@&#x27;:
							mode=&#x27;o&#x27;;
						break;
						case &#x27;&amp;&#x27;:
							mode=&#x27;a&#x27;;
						break;
						case &#x27;~&#x27;:
							mode=&#x27;q&#x27;;
						break;
					}
					if(mode !== undefined){
						user.modes[channel.name].push(mode);
					}
				}
			}
		})
		// RPL_CHANNELMODEIS
		.on(new RegExp(&#x27;:.+ 324 .+ (\\S+) \\+(.+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - channel
			// 2 - modes
			var channel = self.channel(m[1]),
				i,
				modes = m[2];
			if(!channel){
				channel = new Channel(m[1],self);
				self.channels.push(channel);
			}
			for(i in channel.modes){
				if(!(channel.modes[i] instanceof Array)){
					channel.modes[i] = modes.indexOf(i) !== -1;
				}
			}
		})
		// RPL_BANLIST RPL_EXCEPTLIST RPL_INVITELIST
		.on(new RegExp(&#x27;:.+ (367|348|346) \\S+ (\\S+) (\\S+) (\\S+) (\\d+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - code
			// 2 - channel
			// 3 - hostmask
			// 4 - user
			// 5 - timestamp
			var channel = self.channel(m[1]),
				i,
				mode;
			switch(m[1]){
				case 367:mode=&#x27;b&#x27;;break;
				case 348:mode=&#x27;e&#x27;;break;
				case 346:mode=&#x27;I&#x27;;break;
			}
			if(!channel){
				channel = new Channel(m[2],self);
				self.channels.push(channel);
			}
			if(!(channel.modes[mode] instanceof Array)){
				channel.modes[mode] = [];
			}
			if(channel.modes[mode].indexOf(m[3]) === -1){
				channel.modes[mode].push(m[3]);
			}
		})
		// RPL_NOTOPIC RPL_TOPIC
		.on(new RegExp(&#x27;:.+ (331|332) \\S+ (\\S+) :(.+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - code
			// 2 - channel
			// 3 - topic
			var channel = self.channel(m[2]);
			if(!channel){
				channel = new Channel(m[2],self);
				self.channels.push(channel);
			}
			if(m[1] == 331){
				channel._topic = [null];
			}else{
				channel._topic = [m[3]];
			}
		})
		// TOPIC
		.on(new RegExp(&#x27;:(\\S+)\\!(.+)@(.+) TOPIC (\\S+) :(.+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - nick
			// 2 - username
			// 3 - host
			// 4 - channel
			// 5 - topic
			var channel = self.channel(m[4]);
			if(!channel){
				channel = new Channel(m[4],self);
				self.channels.push(channel);
			}
			self.fire(&#x27;topic&#x27;,[channel.topic,m[5]],channel);
			channel._topic = [m[5]];
		})
		// JOIN
		.on(new RegExp(&#x27;:(\\S+)\\!(.+)@(.+) JOIN :(\\S+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - nick
			// 2 - username
			// 3 - host
			// 4 - channel
			var channel = (function(){
					var c = self.channel(m[4]);
					if(!c){
						c = new Channel(m[4],self);
						self.channels.push(c);
					}
					return c;
				})(),
				user,
				owner;
			if(m[1] == self.config.nick){
				channel.who();							// get users
				self.send(&#x27;MODE &#x27;+channel.name);		// get modes
				self.send(&#x27;MODE &#x27;+channel.name+&#x27; b&#x27;);	// get bans
				self.send(&#x27;MODE &#x27;+channel.name+&#x27; e&#x27;);	// get exceptions
				self.send(&#x27;MODE &#x27;+channel.name+&#x27; I&#x27;);	// get invitation masks
			}else{
				user = self.user(m[1]);
				if(!user){
					user = new User(m[1],m[2],m[3],&#x27;&#x27;,self);
					self.users.push(user);
				}
				user.channels.push(channel);
				user.whois();
				self.fire(&#x27;join&#x27;,[],{
					server: self,
					channel: channel,
					user: user,
					owners: owners
				});
			}
		})
		// PART
		.on(new RegExp(&#x27;:(\\S+)\\!(.+)@(.+) PART (\\S+)&#x27;,&#x27;i&#x27;),function(m){
			// 1 - nick
			// 2 - username
			// 3 - host
			// 4 - channel
			var channel = (function(){
					var c = self.channel(m[4]);
					if(!c){
						c = new Channel(m[4],self);
						self.channels.push(c);
					}
					return c;
				})(),
				user = self.user(m[1]);
			if(user &amp;&amp; user.channels.indexOf(channel) != -1){
				user.channels.splice(user.channels.indexOf(channel),1);
				self.fire(&#x27;part&#x27;,[],{
					server: self,
					channel: channel,
					user: user,
					owners: owners
				});
			}
		})
		// MODE
		.on(new RegExp(&#x27;:(.+)\\!(.+)@(.+) MODE (\\S+) (\\S+) ?(.+)?&#x27;,&#x27;i&#x27;),function(m){
			// 1 - nick (doing the action)
			// 2 - username
			// 3 - host
			// 4 - channel
			// 5 - modes
			// 6 - nick (recieving the action)
			var guser = function(nick){
					var user = self.user(nick); //m[6]
					if(!user){
						user = new User(m[1],&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;,self);
						self.users.push(user);
					}
					if(user.channels.indexOf(channel) === -1){
						user.channels.push(channel);
					}
					if(user.modes[channel.name] === undefined){
						user.modes[channel.name] = [];
					}
					return user;
				},
				channel = self.channel(m[4]),
				i,
				ii = 0,
				user,
				state = m[5][0],
				mode,
				index,
				argv = m[6] === undefined?[]:m[6].split(&#x27; &#x27;);
			if(!channel){
				channel = new Channel(m[4],self);
			}
			for(i=1;i&lt;m[5].length;i++){
				mode = m[5][i];
				if(&#x27;+-&#x27;.indexOf(mode) !== -1){
					state = mode;
				}else{
					if(&#x27;vhoaq&#x27;.indexOf(mode) !== -1 &amp;&amp; argv[ii] !== undefined){
						user = guser(argv[ii]);
						if(state == &#x27;+&#x27;){
							if(user.modes[channel.name].indexOf(mode) === -1){
								user.modes[channel.name].push(mode);
							}
						}else{
							index = user.modes[channel.name].indexOf(mode);
							if(index !== -1){
								user.modes[channel.name].splice(index,1);
							}
						}
					}else if(&#x27;bdefIJklLR&#x27;.indexOf() &amp;&amp; argv[ii] !== undefined){
						if(state == &#x27;+&#x27;){
							if(!(channel.modes[mode] instanceof Array)){
								channel.modes[mode] = [];
							}
							channel.modes[mode].push(argv[ii]);
						}else{
							if(channel.modes[mode] instanceof Array){
								index = channel.modes[mode].indexOf(argv[ii]);
								if(index !== -1){
									channel.modes[mode].splice(index,1);
								}
								if(channel.modes[mode].length === 0){
									channel.modes[mode] = false;
								}
							}else{
								channel.modes[mode] = false;
							}
						}
					}else{
						channel.modes[mode] = state == &#x27;+&#x27;;
					}
					ii++;
				}
			}
		})
		.add(&#x27;help&#x27;,function(){
			var i,a;
			if(this.argv.length === 0){
				var s = &#x27;Available commands: &#x27;;
				for(i in self.commands){
					s += i+&#x27;, &#x27;;
				}
				s = s.substr(0,s.length-2);
				self.send(&#x27;PRIVMSG &#x27;+this.channel.name+&#x27; :&#x27;+s);
			}else{
				for(i in this.argv){
					a = this.argv[i];
					if(self.commands[a] === undefined){
						self.send(&#x27;PRIVMSG &#x27;+this.channel.name+&#x27; :&#x27;+a+&#x27;: undefined&#x27;);
					}else{
						self.send(&#x27;PRIVMSG &#x27;+this.channel.name+&#x27; :&#x27;+a+&#x27;: &#x27;+self.commands[a].help);
					}
				}
			}
		},&#x27;Provides information on available commands&#x27;);
	require(&#x27;./api.js&#x27;).servers.push(self);
	var fn = function(i){
		self.scripts[ii] = new Script(config.scripts[ii],self,i);
	};
	for(ii=0;ii&lt;config.scripts.length;ii++){
		self.debug(&#x27; |- &#x27;+config.scripts[ii]);
		self.run(ii+1,fn);
	}
	return self;
};
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
